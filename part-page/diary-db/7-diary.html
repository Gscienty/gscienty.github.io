<h2>坐标系统</h2>
<p>
    <b>坐标范围</b>即对象坐标的x，y，z最小/最大值等其他信息一起存储在场景描述中。
    坐标范围也称为对象的<b>包围盒</b>。
    通过将场景信息传送给观察函数、由观察函数识别可见面、将对象映射到视频映射器上来实现对象的显示。
    扫描转换过程将颜色值等场景信息保存到帧缓存的相应位置，从而在输出设备上显示场景中的对象。
</p>

<h3>屏幕坐标</h3>
<p>
    视频监视器上的位置使用与帧缓存中的像素位置相对应的整数屏幕坐标进行描述。
    <b>行号（y值）列号（x值）</b>
    <br />
    setPixel(x,y);该函数将当前颜色设定值存入帧缓存的整数坐标位置(x,y)处。
    <br />
    getPixel(x,y);该函数参数color得到一个与存储在位置(x,y)的像素中的RGB组合对应的整数值。
</p>

<h3>绝对和相对坐标描述</h3>
<p>
    <b>绝对坐标</b>表示指定的值是所在坐标系统中的实际位置。
    <br />
    <b>相对坐标</b>从离开最后一次引用位置（当前位置）的位移量来指定坐标位置。
</p>

<h2>OpenGL画点函数</h2>
<p>
    默认图院的颜色是白色的，默认点的大小等于一个屏幕像素大小。
    使用glVertex* () 函数可以指定一个点的坐标值。
    <br />
    这里的星号表示该函数要有后缀妈。
    <br />
    OpenGL中的坐标位置可以有二维、三维或四维。
</p>
<p>
    <pre>
        glBegin(GL_POINTS);
        glVertex2i(50, 100);
        glVertex2i(75, 150);
        glVertex2i(100, 200);
        glEnd();
    </pre>
    换一种方法，可以将前面这些点的坐标值以矩阵形式描述：
    <pre>
        int point1[] = {50, 100};
        int point2[] = {75, 150};
        int point3[] = {100, 200};
        glBegin(GL_POINTS);
        glVertex2iv(point1);
        glVertex2iv(point2);
        glVertex2iv(point3);
        glEnd();
    </pre>
    我们可以在C++过程中使用OpenGL画点函数来实现setPixel命令。
</p>
<h2>OpenGL画线函数</h2>
<p>
    使用图元线常量GL_LINES可以连接每一对相邻端点而得到一组直线段。
    <br />
    使用图元常量GL_LINE_STRIP 可以获得折线(polyline)。 此时，显示从第一个端点到最后一个断电之间一组首尾相连的线段。
    <br />
    使用图元常量GL_LINE_LOOP 可以在折线基础上再增加一条直线段，因此，折线序列中最后一个端点与第一个端点相连接。
</p>